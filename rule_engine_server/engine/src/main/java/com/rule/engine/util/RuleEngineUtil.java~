package com.rule.engine.util;

import com.rule.engine.DTO.RuleEvaluateRequestDTO;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RuleEngineUtil {

    private static final String VALID_ATTRIBUTES = "age|department|salary|experience";
    private static final String VALID_OPERATORS = "<|>|=|AND|OR";
    private static final String VALID_PARENS = "\\(|\\)";
    private static final String VALID_TOKEN = VALID_ATTRIBUTES + "|" + VALID_OPERATORS + "|" + VALID_PARENS;

    public static boolean validateRules(List<String> rules) {
        for (String rule : rules) {
            if (!isValidRule(rule)) return false;
        }
        return true;
    }

    private static boolean isValidRule(String rule) {
        // Step 1: Tokenize the rule string
        StringTokenizer tokenizer = new StringTokenizer(rule, " ()", true);
        boolean expectOperand = true;  // To check for proper sequence of operands and operators
        int parenCount = 0;

        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken().trim();
            if (token.isEmpty()) continue;

            // Check if the token is valid
            if (!Pattern.matches(VALID_TOKEN, token) && !isNumeric(token) && !isQuotedString(token)) {
                return false;
            }

            // Check the balance of parentheses
            if (token.equals("(")) {
                parenCount++;
            } else if (token.equals(")")) {
                parenCount--;
                if (parenCount < 0) {
                    return false;
                }
            }

            // Ensure operators and operands are in the correct order
            if (Pattern.matches(VALID_OPERATORS, token)) {
                if (expectOperand) return false; // Operator found when an operand was expected
                expectOperand = true;
            } else if (Pattern.matches(VALID_ATTRIBUTES, token) || isNumeric(token) || isQuotedString(token)) {
                if (!expectOperand) return false; // Operand found when an operator was expected
                expectOperand = false;
            }
        }

        // Check final balance of parentheses and sequence of operands/operators
        if (parenCount != 0) return false;
        if (expectOperand) return false;

        return true;
    }

    private static boolean isNumeric(String str) {
        try {
            Double.parseDouble(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    private static boolean isQuotedString(String str) {
        return str.startsWith("'") && str.endsWith("'");

    }

    private static final Pattern tokenPattern = Pattern.compile(
        "\\(|\\)|\\bAND\\b|\\bOR\\b|>|<|=|\\w+|'[^']+'"
    );

    public static List<String> tokenize(String expression) {
        List<String> tokens = new ArrayList<>();
        Matcher matcher = tokenPattern.matcher(expression);
        while (matcher.find()) {
            tokens.add(matcher.group());
        }
        return tokens;
    }

    public static Map<String,Object> convertRequestToAttributeMap(RuleEvaluateRequestDTO request) {
        validateRequest(request);

        Map<String,Object> requestMap = new HashMap<>();
        requestMap.put("age",request.getAge());
        requestMap.put("salary",request.getSalary());
        requestMap.put("experience",request.getExperience());
        requestMap.put("department",request.getDepartment());

        return requestMap;
    }

    private static void validateRequest(RuleEvaluateRequestDTO request) {
        if(request.getAge() == null || request.getSalary() == null || request.getExperience() == null || request.getDepartment() == null) {
            throw new IllegalArgumentException("missing required parameter");
        }
    }

    public static Map<String,Object> responseJson(Object responseData, Object errorMessage) {
        Map<String,Object> responseMap = new HashMap<>();
        responseMap.put("responseData",responseData);
        responseMap.put("errorMessage",errorMessage);
        return responseMap;
    }
}
